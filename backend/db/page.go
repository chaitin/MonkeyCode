// Code generated by ent, DO NOT EDIT.

package db

import "context"

// PageInfo 分页信息
type PageInfo struct {
	NextToken   string `json:"next_token,omitempty"`
	HasNextPage bool   `json:"has_next_page"`
	TotalCount  int64  `json:"total_count"`
}

func (a *AdminQuery) Page(ctx context.Context, page, size int) ([]*Admin, *PageInfo, error) {
	cnt, err := a.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := a.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (alh *AdminLoginHistoryQuery) Page(ctx context.Context, page, size int) ([]*AdminLoginHistory, *PageInfo, error) {
	cnt, err := alh.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := alh.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (ak *ApiKeyQuery) Page(ctx context.Context, page, size int) ([]*ApiKey, *PageInfo, error) {
	cnt, err := ak.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := ak.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (bp *BillingPlanQuery) Page(ctx context.Context, page, size int) ([]*BillingPlan, *PageInfo, error) {
	cnt, err := bp.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := bp.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (bq *BillingQuotaQuery) Page(ctx context.Context, page, size int) ([]*BillingQuota, *PageInfo, error) {
	cnt, err := bq.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := bq.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (br *BillingRecordQuery) Page(ctx context.Context, page, size int) ([]*BillingRecord, *PageInfo, error) {
	cnt, err := br.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := br.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (bu *BillingUsageQuery) Page(ctx context.Context, page, size int) ([]*BillingUsage, *PageInfo, error) {
	cnt, err := bu.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := bu.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (ic *InviteCodeQuery) Page(ctx context.Context, page, size int) ([]*InviteCode, *PageInfo, error) {
	cnt, err := ic.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := ic.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (m *ModelQuery) Page(ctx context.Context, page, size int) ([]*Model, *PageInfo, error) {
	cnt, err := m.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := m.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (r *RecordQuery) Page(ctx context.Context, page, size int) ([]*Record, *PageInfo, error) {
	cnt, err := r.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := r.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (s *SettingQuery) Page(ctx context.Context, page, size int) ([]*Setting, *PageInfo, error) {
	cnt, err := s.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := s.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (u *UserQuery) Page(ctx context.Context, page, size int) ([]*User, *PageInfo, error) {
	cnt, err := u.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := u.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (ulh *UserLoginHistoryQuery) Page(ctx context.Context, page, size int) ([]*UserLoginHistory, *PageInfo, error) {
	cnt, err := ulh.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	rs, err := ulh.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return rs, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}
